<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Ferramentas para QGIS (Conversor de Polígonos)</title>
        <meta name="description" content="Ferramenta online para converter entre formatos de polígonos, multipolígonos e multipoints, concatenar multipolígonos e gerar comandos SQL para PostGIS." />
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
        <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

        <style>
            body {
                margin: 0;
                padding: 0;
                background-color: #f8f9fa;
                overflow: hidden;
            }
            .app-container {
                display: flex;
                flex-direction: column;
                height: 100vh;
                width: 100vw;
            }
            .converter-section {
                background-color: #fff;
                border-bottom: 1px solid #dee2e6;
                overflow-y: auto;
                transition: all 0.3s ease;
                max-height: 0;
                opacity: 0;
            }
            .converter-section.active {
                max-height: 33vh;
                opacity: 1;
            }
            .converter-content {
                padding: 1rem;
            }
            .map-section {
                flex: 1;
                display: flex;
                overflow: hidden;
                background-color: #fff;
            }
            .map-container {
                flex: 1;
                position: relative;
            }
            .layers-sidebar {
                width: 300px;
                background-color: #f8f9fa;
                border-left: 1px solid #dee2e6;
                overflow-y: auto;
                padding: 1rem;
            }
            #map {
                width: 100%;
                height: 100%;
            }
            .toggle-converter-btn {
                position: fixed;
                top: 10px;
                left: 10px;
                z-index: 1000;
                box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            }
            .form-label {
                font-weight: bold;
            }
            .textarea-container {
                height: 100%;
            }
            textarea {
                resize: vertical;
                min-height: 100px;
                border-radius: 5px;
            }
            .btn-primary {
                background-color: #007bff;
                border-color: #007bff;
            }
            .btn-primary:hover {
                background-color: #0056b3;
                border-color: #0056b3;
            }
            .btn-secondary {
                background-color: #6c757d;
                border-color: #6c757d;
            }
            .btn-secondary:hover {
                background-color: #545b62;
                border-color: #545b62;
            }
            .btn-success {
                background-color: #28a745;
                border-color: #28a745;
            }
            .btn-success:hover {
                background-color: #1e7e34;
                border-color: #1e7e34;
            }
            .form-check-label {
                font-weight: normal;
            }
            #toast-container {
                position: fixed;
                top: 1.5rem;
                right: 1.5rem;
                z-index: 1080;
            }
            .dropzone {
                border: 2px dashed #ccc;
                border-radius: 5px;
                padding: 25px;
                text-align: center;
                margin-bottom: 15px;
                background-color: #f8f9fa;
                cursor: pointer;
            }
            .dropzone.dragover {
                border-color: #007bff;
                background-color: #e9f5ff;
            }
            .nav-tabs .nav-link {
                cursor: pointer;
            }
            .progress-container {
                display: none;
                margin-top: 15px;
            }
            .progress {
                height: 20px;
            }
            footer {
                position: fixed;
                bottom: 0;
                right: 0;
                padding: 0.5rem 1rem;
                background-color: rgba(255,255,255,0.8);
                z-index: 999;
                font-size: 0.75rem;
            }
            .layer-buttons {
                margin-top: 1rem;
            }
        </style>
    </head>
    <body>
        <div id="toast-container"></div>
        <div class="app-container">
            <!-- Toggle Button for Converter -->
            <button class="btn btn-primary toggle-converter-btn" id="toggleConverterBtn">
                <i class="fas fa-exchange-alt"></i> Conversor
            </button>
            
            <!-- Converter Section (Collapsible) -->
            <div class="converter-section" id="converterSection">
                <div class="converter-content">
                    <h5><i class="fas fa-map-marked-alt"></i> Conversor de Polígonos, Multipolígonos e Multipoints</h5>
                    <div class="row mb-2">
                        <div class="col-md-4">
                            <label for="conversionType" class="form-label"><i class="fas fa-exchange-alt"></i> Tipo de Conversão:</label>
                            <select class="form-select form-select-sm" id="conversionType">
                                <option value="polygonsToMultipolygon">Polígonos para Multipolígono</option>
                                <option value="multipolygonToPolygons">Multipolígono para Polígonos</option>
                                <option value="multipointToMultipolygon">Multipoint para Multipolygon</option>
                                <option value="concatenateMultipolygons">Concatenar Multipolígonos</option>
                                <option value="concatenateMultipoints">Concatenar Multipoints</option>
                            </select>
                        </div>
                        <div class="col-md-4">
                            <div class="form-check" style="margin-top: 2rem;">
                                <input class="form-check-input" type="checkbox" id="addSTGeomFromText" />
                                <label class="form-check-label" for="addSTGeomFromText"> <i class="fas fa-code"></i> Adicionar SELECT ST_GeomFromText </label>
                            </div>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-6">
                            <div class="mb-2">
                                <label for="inputText" class="form-label"><i class="fas fa-sign-in-alt"></i> Entrada:</label>
                                <textarea class="form-control" id="inputText" rows="4" placeholder="Cole seu texto aqui..."></textarea>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="mb-2">
                                <label for="outputText" class="form-label"><i class="fas fa-sign-out-alt"></i> Saída:</label>
                                <textarea class="form-control" id="outputText" rows="4" readonly></textarea>
                            </div>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-12 text-end">
                            <button id="convertBtn" class="btn btn-primary btn-sm"><i class="fas fa-cog"></i> Converter</button>
                            <button id="clearBtn" class="btn btn-secondary btn-sm ms-2"><i class="fas fa-eraser"></i> Limpar</button>
                            <button id="fixed-copy-btn" class="btn btn-success btn-sm ms-2"><i class="fas fa-clipboard"></i> Copiar Resultado</button>
                            <button id="addLayerBtn" class="btn btn-info btn-sm ms-2"><i class="fas fa-plus"></i> Adicionar como camada</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Map Section -->
            <div class="map-section">
                <div class="map-container">
                    <div id="map"></div>
                </div>
                <div class="layers-sidebar">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <h6 class="mb-0"><i class="fas fa-layer-group"></i> Camadas</h6>
                        <button id="addLayerManualBtn" class="btn btn-success btn-sm" title="Adicionar camada manualmente">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                    <ul id="layer-list" class="list-group"></ul>
                    <div class="layer-buttons text-center botoesmapa"></div>
                </div>
            </div>
        </div>
        <footer>
            <small>Criado por <a href="https://www.linkedin.com/in/gabrielgortan/" target="_blank" rel="noopener noreferrer">Gabriel Gortan</a></small>
        </footer>
        <!-- Leaflet JS -->
        <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
        <!-- Wicket JS (WKT to Leaflet) -->
        <script src="https://unpkg.com/wicket/wicket.js"></script>
        <script src="https://unpkg.com/wicket/wicket-leaflet.js"></script>
        <!-- Shapefile JS -->
        <script src="https://unpkg.com/shapefile@0.6.6/dist/shapefile.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Leaflet Fullscreen Plugin CSS and JS -->
        <link rel="stylesheet" href="https://api.mapbox.com/mapbox.js/plugins/leaflet-fullscreen/v1.0.1/leaflet.fullscreen.css" />
        <script src="https://api.mapbox.com/mapbox.js/plugins/leaflet-fullscreen/v1.0.1/Leaflet.fullscreen.min.js"></script>


        <script>
            let map, layerGroup, baseLayerGroup;
            let userLayers = [];

            // Função para ler um arquivo como ArrayBuffer (escopo global)
            function readFileAsArrayBuffer(file) {
                return new Promise((resolveFile, rejectFile) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolveFile(e.target.result);
                    reader.onerror = (e) => rejectFile(new Error(`Erro ao ler o arquivo ${file.name}`));
                    reader.readAsArrayBuffer(file);
                });
            }

            // Initialize map on page load
            function initializeMap() {
                if (!map) {
                    map = L.map("map", {
                        fullscreenControl: true,
                    }).setView([0, 0], 2);
                    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                    }).addTo(map);
                    layerGroup = L.layerGroup().addTo(map);
                    baseLayerGroup = L.layerGroup().addTo(map);
                }
            }

            // Toggle converter section
            document.addEventListener("DOMContentLoaded", function () {
                // Initialize the map immediately
                initializeMap();

                const toggleBtn = document.getElementById("toggleConverterBtn");
                const converterSection = document.getElementById("converterSection");
                
                toggleBtn.addEventListener("click", function () {
                    converterSection.classList.toggle("active");
                    const icon = toggleBtn.querySelector("i");
                    if (converterSection.classList.contains("active")) {
                        icon.className = "fas fa-times";
                        toggleBtn.innerHTML = '<i class="fas fa-times"></i> Fechar Conversor';
                    } else {
                        icon.className = "fas fa-exchange-alt";
                        toggleBtn.innerHTML = '<i class="fas fa-exchange-alt"></i> Conversor';
                    }
                });
            });

            function showToast(message, type = "warning") {
                const icons = {
                    success: "fa-check-circle",
                    danger: "fa-exclamation-triangle",
                    warning: "fa-exclamation-circle",
                    info: "fa-info-circle",
                };
                const bg = {
                    success: "bg-success text-white",
                    danger: "bg-danger text-white",
                    warning: "bg-warning text-dark",
                    info: "bg-info text-white",
                };
                const toastId = "toast-" + Date.now();
                const toastHTML = `
         <div id="${toastId}" class="toast align-items-center ${bg[type] || bg.warning}" role="alert" aria-live="assertive" aria-atomic="true" data-bs-delay="4000">
         <div class="d-flex">
         <div class="toast-body">
         <i class="fas ${icons[type] || icons.warning} me-2"></i>${message}
         </div>
         <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Fechar"></button>
         </div>
         </div>
         `;
                const container = document.getElementById("toast-container");
                container.insertAdjacentHTML("beforeend", toastHTML);
                const toastEl = document.getElementById(toastId);
                const toast = new bootstrap.Toast(toastEl);
                toast.show();
                toastEl.addEventListener("hidden.bs.toast", () => {
                    toastEl.remove();
                });
            }

            function plotWKTOnMap(wktString) {
                // Ensure map is initialized
                if (!map) {
                    initializeMap();
                }
                layerGroup.clearLayers();

                wktString = wktString.trim();
                if (wktString.startsWith("SELECT ST_GeomFromText")) {
                    wktString = wktString.replace(/^SELECT ST_GeomFromText\('(.+)'\)$/i, "$1");
                }

                try {
                    const wicket = new Wkt.Wkt();
                    wicket.read(wktString);
                    const obj = wicket.toObject({
                        color: "#007bff",
                        fillColor: "#007bff",
                        fillOpacity: 0.3,
                        opacity: 0.5,
                        weight: 2,
                    });
                    if (Array.isArray(obj)) {
                        obj.forEach((o) => layerGroup.addLayer(o));
                        map.fitBounds(L.featureGroup(obj).getBounds(), { padding: [20, 20] });
                    } else {
                        layerGroup.addLayer(obj);
                        map.fitBounds(obj.getBounds(), { padding: [20, 20] });
                    }
                } catch (e) {
                    showToast("Não foi possível plotar o resultado. Verifique o formato WKT.", "danger");
                }
            }

            function getRandomColor() {
                const hue = Math.floor(Math.random() * 360);
                return `hsl(${hue}, 70%, 60%)`;
            }

            function addLayerToMap(wkt, name = null, color = null, opacity = 0.4) {
                // Ensure map is initialized
                if (!map) {
                    initializeMap();
                }
                if (!baseLayerGroup) {
                    baseLayerGroup = L.layerGroup().addTo(map);
                }
                color = color || getRandomColor();
                name = name || `Camada ${userLayers.length + 1}`;
                wkt = wkt.trim();
                if (wkt.startsWith("SELECT ST_GeomFromText")) {
                    wkt = wkt.replace(/^SELECT ST_GeomFromText\('(.+)'\)$/i, "$1");
                }

                try {
                    // Verificar se é uma GEOMETRYCOLLECTION
                    if (wkt.toUpperCase().startsWith("GEOMETRYCOLLECTION")) {
                        // Extrair as geometrias individuais da coleção
                        const geomMatch = wkt.match(/GEOMETRYCOLLECTION\s*\(\s*(.*)\s*\)/i);
                        if (geomMatch && geomMatch[1]) {
                            const geomParts = splitGeometries(geomMatch[1]);

                            // Criar um grupo de features para todas as geometrias
                            const featureGroup = L.featureGroup();

                            // Processar cada geometria individualmente
                            let success = false;
                            for (const geomPart of geomParts) {
                                try {
                                    const wicket = new Wkt.Wkt();
                                    wicket.read(geomPart);
                                    const obj = wicket.toObject({
                                        color: color,
                                        fillColor: color,
                                        fillOpacity: opacity,
                                        opacity: Math.min(opacity + 0.2, 1),
                                        weight: opacity === 0 ? 0 : 2,
                                    });

                                    if (Array.isArray(obj)) {
                                        obj.forEach((o) => featureGroup.addLayer(o));
                                    } else {
                                        featureGroup.addLayer(obj);
                                    }
                                    success = true;
                                } catch (e) {
                                    console.warn("Erro ao processar parte da geometria:", e);
                                }
                            }

                            if (success) {
                                featureGroup.addTo(baseLayerGroup);
                                userLayers.push({ layer: featureGroup, wkt, color, opacity, name });
                                updateLayerList();
                                map.fitBounds(featureGroup.getBounds(), { padding: [20, 20] });
                                return true;
                            } else {
                                throw new Error("Nenhuma geometria válida encontrada na coleção");
                            }
                        }
                    } else {
                        // Processamento normal para geometrias não-coleção
                        const wicket = new Wkt.Wkt();
                        wicket.read(wkt);
                        const obj = wicket.toObject({
                            color: color,
                            fillColor: color,
                            fillOpacity: opacity,
                            opacity: Math.min(opacity + 0.2, 1),
                            weight: opacity === 0 ? 0 : 2,
                        });
                        let leafletLayer;
                        if (Array.isArray(obj)) {
                            leafletLayer = L.featureGroup(obj);
                        } else {
                            leafletLayer = obj;
                        }
                        leafletLayer.addTo(baseLayerGroup);
                        userLayers.push({ layer: leafletLayer, wkt, color, opacity, name });
                        updateLayerList();
                        map.fitBounds(leafletLayer.getBounds(), { padding: [20, 20] });
                        return true;
                    }
                } catch (e) {
                    console.error("Erro ao adicionar camada:", e);
                    showToast("Não foi possível adicionar a camada. Verifique o formato WKT.", "danger");
                    return false;
                }
            }

            // Função auxiliar para dividir uma string de geometrias em partes individuais
            function splitGeometries(geomString) {
                const geometries = [];
                let depth = 0;
                let start = 0;
                let inQuotes = false;

                for (let i = 0; i < geomString.length; i++) {
                    const char = geomString[i];

                    if (char === '"' || char === "'") {
                        inQuotes = !inQuotes;
                    }

                    if (!inQuotes) {
                        if (char === "(") {
                            if (depth === 0) {
                                // Capturar o tipo de geometria antes do parêntese
                                let j = i - 1;
                                while (j >= 0 && /\s/.test(geomString[j])) j--; // Pular espaços
                                let typeEnd = j + 1;
                                while (j >= 0 && /[A-Z]/i.test(geomString[j])) j--; // Capturar letras
                                let typeStart = j + 1;

                                if (typeStart < typeEnd) {
                                    start = typeStart;
                                }
                            }
                            depth++;
                        } else if (char === ")") {
                            depth--;
                            if (depth === 0) {
                                // Fim de uma geometria
                                geometries.push(geomString.substring(start, i + 1).trim());
                            }
                        } else if (char === "," && depth === 0) {
                            // Separador entre geometrias no nível superior
                            start = i + 1;
                        }
                    }
                }

                return geometries.filter((g) => g && g.trim() !== "");
            }

            function removeLayer(idx) {
                baseLayerGroup.removeLayer(userLayers[idx].layer);
                userLayers.splice(idx, 1);
                updateLayerList();
            }

            function moveLayer(idx, direction) {
                const newIdx = idx + direction;
                if (newIdx < 0 || newIdx >= userLayers.length) return;
                [userLayers[idx], userLayers[newIdx]] = [userLayers[newIdx], userLayers[idx]];
                baseLayerGroup.clearLayers();
                [...userLayers].reverse().forEach((l) => baseLayerGroup.addLayer(l.layer));
                updateLayerList();
            }

            function updateLayerColor(idx, color) {
                userLayers[idx].color = color;
                let style = {
                    color: color,
                    fillColor: color,
                };
                if (userLayers[idx].opacity == 0) {
                    style.color = "transparent";
                    style.fillColor = "transparent";
                    style.opacity = 0;
                    style.fillOpacity = 0;
                    style.weight = 0;
                }
                if (userLayers[idx].layer.setStyle) {
                    userLayers[idx].layer.setStyle(style);
                } else {
                    userLayers[idx].layer.eachLayer((l) => l.setStyle(style));
                }
            }

            function updateLayerOpacity(idx, opacity) {
                userLayers[idx].opacity = opacity;
                let style;
                if (opacity == 0) {
                    style = {
                        fillOpacity: 0,
                        opacity: 0,
                        color: "transparent",
                        fillColor: "transparent",
                        weight: 0,
                    };
                } else {
                    style = {
                        fillOpacity: opacity,
                        opacity: Math.min(opacity + 0.2, 1),
                        color: userLayers[idx].color,
                        fillColor: userLayers[idx].color,
                        weight: 2,
                    };
                }
                if (userLayers[idx].layer.setStyle) {
                    userLayers[idx].layer.setStyle(style);
                } else {
                    userLayers[idx].layer.eachLayer((l) => l.setStyle(style));
                }
            }

            function updateLayerList() {
                const list = document.getElementById("layer-list");
                list.innerHTML = "";
                userLayers.forEach((l, idx) => {
                    const li = document.createElement("li");
                    li.className = "list-group-item d-flex align-items-center justify-content-between";
                    li.innerHTML = `
         <span>
         <input type="color" value="${rgb2hex(l.color)}" style="width: 32px; height: 32px; border: none; vertical-align: middle;" data-idx="${idx}" class="layer-color-picker" title="Cor da camada">
         <input type="range" min="0" max="1" step="0.05" value="${l.opacity}" data-idx="${idx}" class="layer-opacity-slider" style="width:80px; vertical-align: middle;" title="Transparência">
         <strong style="margin-left:8px;">${l.name}</strong>
         </span>
         <span>
         <button class="btn btn-sm btn-light move-up" data-idx="${idx}" title="Subir camada"><i class="fas fa-arrow-up"></i></button>
         <button class="btn btn-sm btn-light move-down" data-idx="${idx}" title="Descer camada"><i class="fas fa-arrow-down"></i></button>
         <button class="btn btn-sm btn-warning edit-layer" data-idx="${idx}" title="Editar camada"><i class="fas fa-edit"></i></button>
         <button class="btn btn-sm btn-danger remove-layer" data-idx="${idx}" title="Remover camada"><i class="fas fa-trash"></i></button>
         </span>
         `;
                    list.appendChild(li);
                });

                document.querySelectorAll(".remove-layer").forEach((btn) => {
                    btn.onclick = (e) => removeLayer(Number(btn.dataset.idx));
                });
                document.querySelectorAll(".move-up").forEach((btn) => {
                    btn.onclick = (e) => moveLayer(Number(btn.dataset.idx), -1);
                });
                document.querySelectorAll(".move-down").forEach((btn) => {
                    btn.onclick = (e) => moveLayer(Number(btn.dataset.idx), 1);
                });
                document.querySelectorAll(".layer-color-picker").forEach((input) => {
                    input.oninput = (e) => updateLayerColor(Number(input.dataset.idx), input.value);
                });
                document.querySelectorAll(".layer-opacity-slider").forEach((input) => {
                    input.oninput = (e) => updateLayerOpacity(Number(input.dataset.idx), Number(input.value));
                });
            }

            function rgb2hex(color) {
                if (color.startsWith("#")) return color;
                if (color.startsWith("hsl")) {
                    const hsl = color.match(/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/);
                    if (!hsl) return "#8888";
                    let [h, s, l] = [Number(hsl[1]), Number(hsl[2]) / 100, Number(hsl[3]) / 100];
                    let c = (1 - Math.abs(2 * l - 1)) * s;
                    let x = c * (1 - Math.abs(((h / 60) % 2) - 1));
                    let m = l - c / 2;
                    let [r, g, b] = [0, 0, 0];
                    if (h < 60) [r, g, b] = [c, x, 0];
                    else if (h < 120) [r, g, b] = [x, c, 0];
                    else if (h < 180) [r, g, b] = [0, c, x];
                    else if (h < 240) [r, g, b] = [0, x, c];
                    else if (h < 300) [r, g, b] = [x, 0, c];
                    else [r, g, b] = [c, 0, x];
                    r = Math.round((r + m) * 255);
                    g = Math.round((g + m) * 255);
                    b = Math.round((b + m) * 255);
                    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
                }
                if (color.startsWith("rgb")) {
                    const rgb = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                    if (!rgb) return "#8888";
                    return "#" + ((1 << 24) + (Number(rgb[1]) << 16) + (Number(rgb[2]) << 8) + Number(rgb[3])).toString(16).slice(1);
                }
                return "#8888";
            }

            // Função para converter geometria GeoJSON para WKT
            function geomToWKT(geom) {
                if (!geom || !geom.type) return null;

                switch (geom.type.toUpperCase()) {
                    case "POINT":
                        return `POINT (${geom.coordinates.join(" ")})`;

                    case "LINESTRING":
                        return `LINESTRING (${geom.coordinates.map((c) => c.join(" ")).join(", ")})`;

                    case "POLYGON":
                        return `POLYGON (${geom.coordinates.map((ring) => "(" + ring.map((c) => c.join(" ")).join(", ") + ")").join(", ")})`;

                    case "MULTIPOINT":
                        return `MULTIPOINT (${geom.coordinates.map((c) => "(" + c.join(" ") + ")").join(", ")})`;

                    case "MULTILINESTRING":
                        return `MULTILINESTRING (${geom.coordinates.map((line) => "(" + line.map((c) => c.join(" ")).join(", ") + ")").join(", ")})`;

                    case "MULTIPOLYGON":
                        return `MULTIPOLYGON (${geom.coordinates.map((poly) => "(" + poly.map((ring) => "(" + ring.map((c) => c.join(" ")).join(", ") + ")").join(", ") + ")").join(", ")})`;

                    case "GEOMETRYCOLLECTION":
                        return `GEOMETRYCOLLECTION (${geom.geometries
                            .map((g) => geomToWKT(g))
                            .filter(Boolean)
                            .join(", ")})`;

                    default:
                        return null;
                }
            }

            // Função para processar arquivos Shapefile
            function processShapefile(files) {
                return new Promise((resolve, reject) => {
                    try {
                        // Verificar se há arquivos
                        if (!files || files.length === 0) {
                            reject(new Error("Nenhum arquivo selecionado"));
                            return;
                        }

                        // Encontrar o arquivo .shp
                        let shpFile = null;
                        let dbfFile = null;
                        let prjFile = null;
                        let shxFile = null;

                        for (let i = 0; i < files.length; i++) {
                            const fileName = files[i].name.toLowerCase();
                            if (fileName.endsWith(".shp")) {
                                shpFile = files[i];
                            } else if (fileName.endsWith(".dbf")) {
                                dbfFile = files[i];
                            } else if (fileName.endsWith(".prj")) {
                                prjFile = files[i];
                            } else if (fileName.endsWith(".shx")) {
                                shxFile = files[i];
                            }
                        }

                        if (!shpFile) {
                            reject(new Error("Arquivo .shp não encontrado"));
                            return;
                        }

                        // Mostrar mensagem de processamento
                        showToast("Processando arquivo. Isso pode levar alguns instantes para arquivos grandes...", "info");

                        // Verificar tamanho do arquivo
                        const fileSizeMB = shpFile.size / (1024 * 1024);
                        if (fileSizeMB > 50) {
                            showToast(`Arquivo grande (${fileSizeMB.toFixed(1)} MB). O processamento pode levar mais tempo.`, "warning");
                        }

                        // Atualizar a barra de progresso
                        function updateProgress(percent) {
                            const progressBar = document.getElementById("shapefileProgressBar");
                            if (progressBar) {
                                progressBar.style.width = `${percent}%`;
                                progressBar.setAttribute("aria-valuenow", percent);
                            }
                        }

                        // Ler os arquivos necessários
                        updateProgress(10);

                        // Verificar se a biblioteca shapefile está disponível
                        if (typeof shapefile === "undefined") {
                            throw new Error("Biblioteca shapefile não carregada. Verifique a conexão com a internet.");
                        }

                        Promise.all([readFileAsArrayBuffer(shpFile), dbfFile ? readFileAsArrayBuffer(dbfFile) : Promise.resolve(null), shxFile ? readFileAsArrayBuffer(shxFile) : Promise.resolve(null)])
                            .then(([shpBuffer, dbfBuffer, shxBuffer]) => {
                                updateProgress(30);

                                // Usar a biblioteca shapefile para ler o arquivo
                                let shapefilePromise;

                                if (dbfBuffer) {
                                    shapefilePromise = shapefile.read(shpBuffer, dbfBuffer);
                                } else {
                                    shapefilePromise = shapefile.read(shpBuffer);
                                }

                                return shapefilePromise;
                            })
                            .then((geojson) => {
                                updateProgress(60);

                                // Verificar se temos um GeoJSON válido
                                if (!geojson) {
                                    throw new Error("O arquivo não contém geometrias válidas");
                                }

                                // Extrair as geometrias do GeoJSON
                                let features = [];

                                if (geojson.type === "FeatureCollection" && geojson.features) {
                                    features = geojson.features;
                                } else if (geojson.type === "Feature") {
                                    features = [geojson];
                                } else if (geojson.geometry) {
                                    features = [geojson];
                                } else {
                                    // Tentar interpretar como geometria direta
                                    features = [{ type: "Feature", geometry: geojson }];
                                }

                                updateProgress(70);

                                // Verificar se temos features válidas
                                if (features.length === 0) {
                                    throw new Error("Nenhuma geometria válida encontrada no arquivo");
                                }

                                // Converter para WKT manualmente
                                let wktStrings = [];
                                let validFeatureCount = 0;

                                for (let i = 0; i < features.length; i++) {
                                    const feature = features[i];
                                    if (!feature.geometry) continue;

                                    try {
                                        const wkt = geomToWKT(feature.geometry);
                                        if (wkt) {
                                            wktStrings.push(wkt);
                                            validFeatureCount++;
                                        }
                                    } catch (e) {
                                        console.warn("Erro ao converter geometria para WKT:", e);
                                    }
                                }

                                updateProgress(90);

                                // Se não conseguimos converter nenhuma geometria, lançar erro
                                if (wktStrings.length === 0) {
                                    throw new Error("Não foi possível converter as geometrias para WKT");
                                }

                                // Determinar o tipo de geometria predominante
                                const geometryTypes = {};
                                wktStrings.forEach((wkt) => {
                                    const type = wkt.split("(")[0].trim();
                                    geometryTypes[type] = (geometryTypes[type] || 0) + 1;
                                });

                                let predominantType = "";
                                let maxCount = 0;
                                for (const type in geometryTypes) {
                                    if (geometryTypes[type] > maxCount) {
                                        maxCount = geometryTypes[type];
                                        predominantType = type;
                                    }
                                }

                                // Criar WKT final
                                let finalWkt = "";

                                // Se todas as geometrias são do mesmo tipo, podemos criar um MULTI* WKT
                                if (predominantType && Object.keys(geometryTypes).length === 1) {
                                    if (predominantType === "POLYGON") {
                                        // Extrair os conteúdos dos parênteses para criar um MULTIPOLYGON
                                        const polygonContents = wktStrings
                                            .map((wkt) => {
                                                const match = wkt.match(/POLYGON\s*\(\((.*?)\)\)/is);
                                                return match ? `((${match[1]}))` : null;
                                            })
                                            .filter(Boolean);

                                        if (polygonContents.length > 0) {
                                            finalWkt = `MULTIPOLYGON (${polygonContents.join(", ")})`;
                                        }
                                    } else if (predominantType === "POINT") {
                                        // Extrair os conteúdos dos parênteses para criar um MULTIPOINT
                                        const pointContents = wktStrings
                                            .map((wkt) => {
                                                const match = wkt.match(/POINT\s*\(\s*(.*?)\s*\)/i);
                                                return match ? `(${match[1]})` : null;
                                            })
                                            .filter(Boolean);

                                        if (pointContents.length > 0) {
                                            finalWkt = `MULTIPOINT (${pointContents.join(", ")})`;
                                        }
                                    } else if (predominantType === "LINESTRING") {
                                        // Extrair os conteúdos dos parênteses para criar um MULTILINESTRING
                                        const lineContents = wktStrings
                                            .map((wkt) => {
                                                const match = wkt.match(/LINESTRING\s*\(\s*(.*?)\s*\)/i);
                                                return match ? `(${match[1]})` : null;
                                            })
                                            .filter(Boolean);

                                        if (lineContents.length > 0) {
                                            finalWkt = `MULTILINESTRING (${lineContents.join(", ")})`;
                                        }
                                    }
                                } else if (wktStrings.length > 1) {
                                    // Se temos tipos diferentes ou não conseguimos criar um MULTI* WKT,
                                    // vamos criar uma GEOMETRYCOLLECTION para incluir todas as geometrias
                                    finalWkt = `GEOMETRYCOLLECTION (${wktStrings.join(", ")})`;
                                } else if (wktStrings.length === 1) {
                                    // Se temos apenas uma geometria, usamos ela diretamente
                                    finalWkt = wktStrings[0];
                                }

                                updateProgress(100);

                                // Criar o objeto de resultado
                                const wktData = {
                                    wkt: finalWkt,
                                    count: validFeatureCount,
                                    name: shpFile.name.replace(/\.[^/.]+$/, ""),
                                };

                                resolve(wktData);
                            })
                            .catch((error) => {
                                console.error("Erro ao processar shapefile:", error);
                                reject(new Error("Erro ao processar o arquivo: " + error.message));
                            });
                    } catch (error) {
                        console.error("Erro ao iniciar processamento:", error);
                        reject(new Error("Erro ao iniciar processamento: " + error.message));
                    }
                });
            }

            // Função para limpar a memória após o processamento
            function cleanupMemory() {
                if (window.gc) window.gc();
            }

            // Função para lidar com o upload de Shapefile
            function handleShapefileUpload(files) {
                // Mostrar a barra de progresso
                const progressContainer = document.getElementById("shapefileProgressContainer");
                progressContainer.style.display = "flex";

                // Processar o Shapefile
                processShapefile(files)
                    .then((wktData) => {
                        // Adicionar o resultado ao textarea de saída
                        outputText.value = wktData.wkt;

                        // Verificar se o WKT é válido
                        if (!wktData.wkt || wktData.wkt.trim() === "") {
                            throw new Error("O WKT gerado está vazio ou inválido");
                        }

                        try {
                            // Testar se o WKT é válido criando um objeto Wicket
                            const wicket = new Wkt.Wkt();
                            wicket.read(wktData.wkt);

                            // Se chegou aqui, o WKT é válido

                            // Adicionar como nova camada automaticamente
                            const layerName = wktData.name || `Camada ${userLayers.length + 1}`;
                            const randomColor = getRandomColor();

                            // Adicionar ao mapa
                            const success = addLayerToMap(wktData.wkt, layerName, randomColor);

                            if (success) {
                                // Fechar o modal
                                addLayerModal.hide();

                                // Mostrar mensagem de sucesso
                                if (wktData.wkt.startsWith("GEOMETRYCOLLECTION")) {
                                    showToast(`Shapefile adicionado como camada "${layerName}" com ${wktData.count} geometrias combinadas.`, "success");
                                } else {
                                    showToast(`Shapefile adicionado como camada "${layerName}" com ${wktData.count} feições.`, "success");
                                }
                            } else {
                                showToast("Não foi possível adicionar a camada. Verifique o formato do arquivo.", "danger");
                            }
                        } catch (error) {
                            console.error("Erro ao validar WKT:", error);
                            showToast("O WKT gerado não é válido. Verifique o formato do arquivo.", "danger");
                        }

                        // Limpar a memória
                        cleanupMemory();
                    })
                    .catch((error) => {
                        showToast("Erro ao processar o arquivo: " + error.message, "danger");
                    })
                    .finally(() => {
                        // Esconder a barra de progresso
                        progressContainer.style.display = "none";
                    });
            }

            // Funções de conversão
            function convertPolygonsToMultipolygon(input) {
                const polygons = input.split("\n").filter((line) => line.trim() !== "");
                if (polygons.length === 0) return "";
                if (input.trim().toUpperCase().startsWith("MULTIPOLYGON")) return input.trim();
                const polygonParts = polygons
                    .map((polygon) => {
                        const match = polygon.match(/POLYGON\s*\(\((.*?)\)\)/i);
                        if (match && match[1]) return `(${match[1]})`;
                        return null;
                    })
                    .filter((part) => part !== null);
                if (polygonParts.length === 0) {
                    return "Formato de entrada inválido. Verifique se os polígonos estão no formato correto.";
                }
                return `MULTIPOLYGON (${polygonParts.join(",")})`;
            }

            function convertMultipolygonToPolygons(input) {
                if (!input.trim().toUpperCase().startsWith("MULTIPOLYGON")) {
                    return "A entrada deve ser um MULTIPOLYGON.";
                }
                const multipolygonMatch = input.match(/MULTIPOLYGON\s*\(\((.*?)\)\)/is);
                if (!multipolygonMatch || !multipolygonMatch[1]) {
                    return "Formato de MULTIPOLYGON inválido.";
                }
                let content = multipolygonMatch[1];
                const polygons = [];
                let depth = 0,
                    start = 0;
                for (let i = 0; i < content.length; i++) {
                    if (content[i] === "(") {
                        if (depth === 0) start = i;
                        depth++;
                    } else if (content[i] === ")") {
                        depth--;
                        if (depth === 0) polygons.push(content.substring(start, i + 1));
                    }
                }
                return polygons.map((polygon) => `POLYGON (${polygon})`).join("\n");
            }

            function concatenateMultipolygons(input) {
                const regex = /MULTIPOLYGON\s*\(\s*(\(\(.*?\)\))\s*\)/gis;
                let match;
                const allPolygons = [];
                while ((match = regex.exec(input)) !== null) {
                    const group = match[1];
                    let depth = 0,
                        start = -1;
                    for (let i = 0; i < group.length; i++) {
                        if (group[i] === "(") {
                            if (depth === 0) start = i;
                            depth++;
                        } else if (group[i] === ")") {
                            depth--;
                            if (depth === 0 && start !== -1) {
                                allPolygons.push(group.substring(start, i + 1));
                                start = -1;
                            }
                        }
                    }
                }
                if (allPolygons.length === 0) {
                    return "Formato de entrada inválido. Verifique se os multipolígonos estão no formato correto.";
                }
                return `MULTIPOLYGON (${allPolygons.join(",")})`;
            }

            function convertMultipointToMultipolygon(input) {
                const lines = input
                    .split("\n")
                    .map((l) => l.trim())
                    .filter((l) => l.length > 0);
                let points = [];
                lines.forEach((line) => {
                    let multiMatch = line.match(/MULTIPOINT\s*\(\s*(.*)\s*\)/i);
                    if (multiMatch) {
                        let content = multiMatch[1].trim();
                        if (content.startsWith("(")) {
                            let innerPoints = [...content.matchAll(/\(([^()]+)\)/g)].map((m) => m[1].trim());
                            points.push(...innerPoints);
                        } else {
                            points.push(...content.split(",").map((p) => p.trim()));
                        }
                        return;
                    }
                    let pointMatch = line.match(/POINT\s*\(\s*([^\)]+)\s*\)/i);
                    if (pointMatch) {
                        points.push(pointMatch[1].trim());
                        return;
                    }
                    if (/^-?\d+(\.\d+)?\s+-?\d+(\.\d+)?$/.test(line)) {
                        points.push(line);
                    }
                });
                if (points.length === 0) {
                    return "Nenhum ponto válido encontrado.";
                }
                const size = 0.00001;
                const polygons = points.map((point) => {
                    const [x, y] = point.split(/\s+/).map(Number);
                    return `((${x - size} ${y - size}, ${x + size} ${y - size}, ${x + size} ${y + size}, ${x - size} ${y + size}, ${x - size} ${y - size}))`;
                });
                return `MULTIPOLYGON (${polygons.join(", ")})`;
            }

            function concatenateMultipoints(input) {
                const lines = input
                    .split("\n")
                    .map((l) => l.trim())
                    .filter((l) => l.length > 0);
                let points = [];
                lines.forEach((line) => {
                    let multiMatch = line.match(/MULTIPOINT\s*\(\s*(.*)\s*\)/i);
                    if (multiMatch) {
                        let content = multiMatch[1].trim();
                        if (content.startsWith("(")) {
                            let innerPoints = [...content.matchAll(/\(([^()]+)\)/g)].map((m) => m[1].trim());
                            points.push(...innerPoints);
                        } else {
                            points.push(...content.split(",").map((p) => p.trim()));
                        }
                        return;
                    }
                    let pointMatch = line.match(/POINT\s*\(\s*([^\)]+)\s*\)/i);
                    if (pointMatch) {
                        points.push(pointMatch[1].trim());
                        return;
                    }
                    if (/^-?\d+(\.\d+)?\s+-?\d+(\.\d+)?$/.test(line)) {
                        points.push(line);
                    }
                });
                if (points.length === 0) {
                    return "Nenhum ponto válido encontrado.";
                }
                return "MULTIPOINT(" + points.map((pt) => "(" + pt + ")").join(", ") + ")";
            }
        </script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                const inputText = document.getElementById("inputText");
                const outputText = document.getElementById("outputText");
                const convertBtn = document.getElementById("convertBtn");
                const clearBtn = document.getElementById("clearBtn");
                const copyBtn = document.getElementById("fixed-copy-btn");
                const conversionType = document.getElementById("conversionType");
                const addSTGeomFromText = document.getElementById("addSTGeomFromText");
                const addLayerBtn = document.getElementById("addLayerBtn");
                const addLayerManualBtn = document.getElementById("addLayerManualBtn");

                // Criar o modal para adicionar camadas
                const addLayerModalHTML = `
         <div class="modal fade" id="addLayerModal" tabindex="-1" aria-labelledby="addLayerModalLabel" aria-hidden="true">
             <div class="modal-dialog modal-lg">
                 <div class="modal-content">
                     <div class="modal-header">
                         <h5 class="modal-title" id="addLayerModalLabel">Adicionar Camada</h5>
                         <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
                     </div>
                     <div class="modal-body">
                         <ul class="nav nav-tabs" id="addLayerTabs" role="tablist">
                             <li class="nav-item" role="presentation">
                                 <button class="nav-link active" id="wkt-tab" data-bs-toggle="tab" data-bs-target="#wkt-tab-pane" type="button" role="tab" aria-controls="wkt-tab-pane" aria-selected="true">WKT</button>
                             </li>
                             <li class="nav-item" role="presentation">
                                 <button class="nav-link" id="shapefile-tab" data-bs-toggle="tab" data-bs-target="#shapefile-tab-pane" type="button" role="tab" aria-controls="shapefile-tab-pane" aria-selected="false">Shapefile</button>
                             </li>
                         </ul>
                         <div class="tab-content" id="addLayerTabContent">
                             <div class="tab-pane fade show active" id="wkt-tab-pane" role="tabpanel" aria-labelledby="wkt-tab" tabindex="0">
                                 <form id="editLayerForm" class="mt-3">
                                     <div class="mb-3">
                                         <label for="editLayerName" class="form-label">Nome da Camada</label>
                                         <input type="text" class="form-control" id="editLayerName" required>
                                     </div>
                                     <div class="mb-3">
                                         <label for="editLayerWKT" class="form-label">Conteúdo WKT</label>
                                         <textarea class="form-control" id="editLayerWKT" rows="4" required></textarea>
                                     </div>
                                     <div class="text-end">
                                         <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                                         <button type="submit" class="btn btn-primary">Adicionar Camada</button>
                                     </div>
                                 </form>
                             </div>
                             <div class="tab-pane fade" id="shapefile-tab-pane" role="tabpanel" aria-labelledby="shapefile-tab" tabindex="0">
                                 <div class="mt-3">
                                     <div class="alert alert-danger" role="alert">
                                         <i class="fas fa-exclamation-triangle me-2"></i>
                                         <strong>Atenção!</strong> Esta funcionalidade está em desenvolvimento e pode não funcionar corretamente.
                                     </div>
                                     <div id="shapefileDropzone" class="dropzone">
                                         <div class="dz-message">
                                             <i class="fas fa-upload fa-2x mb-2"></i>
                                             <p>Arraste e solte arquivos .shp aqui ou clique para selecionar</p>
                                             <p class="small text-muted">Você pode selecionar múltiplos arquivos (.shp, .dbf, .shx, .prj)</p>
                                         </div>
                                         <input type="file" id="shapefileInput" multiple style="display: none;" accept=".shp,.dbf,.shx,.prj">
                                     </div>
                                     <div id="shapefileProgressContainer" class="progress-container">
                                         <div class="progress">
                                             <div id="shapefileProgressBar" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0%"></div>
                                         </div>
                                     </div>
                                 </div>
                             </div>
                         </div>
                     </div>
                 </div>
             </div>
         </div>`;

                // Adicionar o modal ao DOM

                let addLayerModal;
                let editingLayerIdx = null;
                let isAddingManualLayer = false;
                document.body.insertAdjacentHTML("beforeend", addLayerModalHTML);
                addLayerModal = new bootstrap.Modal(document.getElementById("addLayerModal"));

                // Configurar o dropzone para arquivos shapefile
                const dropzone = document.getElementById("shapefileDropzone");
                const fileInput = document.getElementById("shapefileInput");

                dropzone.addEventListener("click", () => {
                    fileInput.click();
                });

                dropzone.addEventListener("dragover", (e) => {
                    e.preventDefault();
                    dropzone.classList.add("dragover");
                });

                dropzone.addEventListener("dragleave", () => {
                    dropzone.classList.remove("dragover");
                });

                dropzone.addEventListener("drop", (e) => {
                    e.preventDefault();
                    dropzone.classList.remove("dragover");
                    if (e.dataTransfer.files.length > 0) {
                        handleShapefileUpload(e.dataTransfer.files);
                    }
                });

                fileInput.addEventListener("change", () => {
                    if (fileInput.files.length > 0) {
                        handleShapefileUpload(fileInput.files);
                    }
                });

                convertBtn.addEventListener("click", function () {
                    const input = inputText.value.trim();
                    if (!input) {
                        showToast("Por favor, insira o texto para conversão.", "warning");
                        return;
                    }
                    let convertedText;
                    if (conversionType.value === "polygonsToMultipolygon") {
                        convertedText = convertPolygonsToMultipolygon(input);
                    } else if (conversionType.value === "multipolygonToPolygons") {
                        convertedText = convertMultipolygonToPolygons(input);
                    } else if (conversionType.value === "concatenateMultipolygons") {
                        convertedText = concatenateMultipolygons(input);
                    } else if (conversionType.value === "multipointToMultipolygon") {
                        convertedText = convertMultipointToMultipolygon(input);
                    } else if (conversionType.value === "concatenateMultipoints") {
                        convertedText = concatenateMultipoints(input);
                    } else {
                        convertedText = "";
                    }
                    if (convertedText.startsWith("Formato de entrada inválido") || convertedText.startsWith("A entrada deve ser") || convertedText.startsWith("Nenhum ponto válido")) {
                        showToast(convertedText, "danger");
                        outputText.value = "";
                    } else {
                        if (addSTGeomFromText.checked) {
                            convertedText = `SELECT ST_GeomFromText('${convertedText}')`;
                        }
                        outputText.value = convertedText;
                        showToast("Conversão realizada com sucesso!", "success");
                        plotWKTOnMap(convertedText);
                    }
                });
                clearBtn.addEventListener("click", function () {
                    inputText.value = "";
                    outputText.value = "";
                    if (map && layerGroup) {
                        layerGroup.clearLayers();
                    }
                });
                copyBtn.addEventListener("click", function () {
                    if (!outputText.value) {
                        showToast("Não há resultado para copiar.", "warning");
                        return;
                    }
                    outputText.select();
                    try {
                        document.execCommand("copy");
                        showToast("Resultado copiado para a área de transferência!", "success");
                    } catch (err) {
                        navigator.clipboard
                            .writeText(outputText.value)
                            .then(() => {
                                showToast("Resultado copiado para a área de transferência!", "success");
                            })
                            .catch((err) => {
                                showToast("Erro ao copiar: " + err.message, "danger");
                                console.error("Erro ao copiar: ", err);
                            });
                    }
                });

                addLayerBtn.onclick = function () {
                    const wkt = outputText.value.trim();
                    if (!wkt) {
                        showToast("Não há resultado para adicionar como camada.", "warning");
                        return;
                    }
                    isAddingManualLayer = true;
                    editingLayerIdx = null;
                    document.getElementById("addLayerModalLabel").textContent = "Adicionar Camada Convertida";
                    document.getElementById("editLayerName").value = `Camada ${userLayers.length + 1}`;
                    document.getElementById("editLayerWKT").value = wkt;
                    addLayerModal.show();
                };

                addLayerManualBtn.addEventListener("click", function () {
                    isAddingManualLayer = true;
                    editingLayerIdx = null;
                    document.getElementById("addLayerModalLabel").textContent = "Adicionar Camada Manualmente";
                    document.getElementById("editLayerName").value = "";
                    document.getElementById("editLayerWKT").value = "";
                    addLayerModal.show();
                });

                document.addEventListener("click", function (e) {
                    if (e.target.closest(".edit-layer")) {
                        isAddingManualLayer = false;
                        const idx = Number(e.target.closest(".edit-layer").dataset.idx);
                        editingLayerIdx = idx;
                        document.getElementById("addLayerModalLabel").textContent = "Editar Camada";
                        document.getElementById("editLayerName").value = userLayers[idx].name;
                        document.getElementById("editLayerWKT").value = userLayers[idx].wkt;
                        addLayerModal.show();
                    }
                });

                document.getElementById("editLayerForm").addEventListener("submit", function (e) {
                    e.preventDefault();
                    const newName = document.getElementById("editLayerName").value.trim();
                    const newWKT = document.getElementById("editLayerWKT").value.trim();
                    if (!newName || !newWKT) return;

                    if (isAddingManualLayer) {
                        addLayerToMap(newWKT, newName);
                        showToast("Camada adicionada com sucesso!", "success");
                        addLayerModal.hide();
                        isAddingManualLayer = false;
                        return;
                    }

                    baseLayerGroup.removeLayer(userLayers[editingLayerIdx].layer);
                    try {
                        const wicket = new Wkt.Wkt();
                        wicket.read(newWKT);
                        const obj = wicket.toObject({
                            color: userLayers[editingLayerIdx].color,
                            fillColor: userLayers[editingLayerIdx].color,
                            fillOpacity: userLayers[editingLayerIdx].opacity,
                            opacity: Math.min(userLayers[editingLayerIdx].opacity + 0.2, 1),
                            weight: userLayers[editingLayerIdx].opacity === 0 ? 0 : 2,
                        });
                        let leafletLayer;
                        if (Array.isArray(obj)) {
                            leafletLayer = L.featureGroup(obj);
                        } else {
                            leafletLayer = obj;
                        }
                        leafletLayer.addTo(baseLayerGroup);

                        userLayers[editingLayerIdx].name = newName;
                        userLayers[editingLayerIdx].wkt = newWKT;
                        userLayers[editingLayerIdx].layer = leafletLayer;

                        baseLayerGroup.clearLayers();
                        userLayers.forEach((l) => baseLayerGroup.addLayer(l.layer));
                        updateLayerList();
                        showToast("Camada editada com sucesso!", "success");
                        addLayerModal.hide();
                    } catch (err) {
                        showToast("Erro ao atualizar camada. Verifique o WKT.", "danger");
                    }
                });
            });

            // Adicione estas funções ao arquivo JavaScript existente

            // Função para salvar as camadas no localStorage
            function saveLayersToLocalStorage() {
                const layersData = userLayers.map((layer) => ({
                    name: layer.name,
                    wkt: layer.wkt,
                    color: layer.color,
                    opacity: layer.opacity,
                }));

                localStorage.setItem("savedLayers", JSON.stringify(layersData));
                showToast("Camadas salvas com sucesso!", "success");
            }

            // Função para carregar as camadas do localStorage
            function loadLayersFromLocalStorage() {
                try {
                    const savedData = localStorage.getItem("savedLayers");
                    if (!savedData) return false;

                    const layersData = JSON.parse(savedData);
                    if (!Array.isArray(layersData) || layersData.length === 0) return false;

                    // Limpar camadas existentes
                    if (baseLayerGroup) {
                        baseLayerGroup.clearLayers();
                        userLayers = [];
                    }

                    // Adicionar camadas salvas
                    layersData.forEach((layerData) => {
                        addLayerToMap(layerData.wkt, layerData.name, layerData.color, layerData.opacity);
                    });

                    showToast("Camadas carregadas com sucesso!", "info");
                    return true;
                } catch (error) {
                    console.error("Erro ao carregar camadas:", error);
                    showToast("Erro ao carregar camadas salvas", "danger");
                    return false;
                }
            }

            // Função para exportar as camadas como arquivo JSON
            function exportLayers() {
                if (userLayers.length === 0) {
                    showToast("Não há camadas para exportar", "warning");
                    return;
                }

                const layersData = userLayers.map((layer) => ({
                    name: layer.name,
                    wkt: layer.wkt,
                    color: layer.color,
                    opacity: layer.opacity,
                }));

                const dataStr = JSON.stringify(layersData, null, 2);
                const dataBlob = new Blob([dataStr], { type: "application/json" });
                const url = URL.createObjectURL(dataBlob);

                const link = document.createElement("a");
                link.href = url;
                link.download = "camadas_exportadas.json";
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                showToast("Camadas exportadas com sucesso!", "success");
            }

            // Função para importar camadas de um arquivo JSON
            function importLayers(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();

                    reader.onload = (e) => {
                        try {
                            const layersData = JSON.parse(e.target.result);

                            if (!Array.isArray(layersData)) {
                                throw new Error("Formato de arquivo inválido");
                            }

                            // Perguntar se deseja substituir ou adicionar às camadas existentes
                            const shouldReplace = confirm("Deseja substituir as camadas existentes? Clique em OK para substituir ou Cancelar para adicionar às camadas existentes.");

                            if (shouldReplace && baseLayerGroup) {
                                baseLayerGroup.clearLayers();
                                userLayers = [];
                            }

                            // Adicionar camadas importadas
                            let addedCount = 0;
                            layersData.forEach((layerData) => {
                                if (layerData.wkt && layerData.name) {
                                    const success = addLayerToMap(layerData.wkt, layerData.name, layerData.color || getRandomColor(), layerData.opacity !== undefined ? layerData.opacity : 0.4);
                                    if (success) addedCount++;
                                }
                            });

                            if (addedCount > 0) {
                                showToast(`${addedCount} camadas importadas com sucesso!`, "success");
                                saveLayersToLocalStorage(); // Salvar automaticamente após importar
                                resolve(true);
                            } else {
                                throw new Error("Nenhuma camada válida encontrada no arquivo");
                            }
                        } catch (error) {
                            console.error("Erro ao importar camadas:", error);
                            showToast("Erro ao importar camadas: " + error.message, "danger");
                            reject(error);
                        }
                    };

                    reader.onerror = (e) => {
                        reject(new Error("Erro ao ler o arquivo"));
                    };

                    reader.readAsText(file);
                });
            }

            // Adicione estes botões ao HTML, logo após os botões existentes na div com class="col-12 text-end"
            // Adicione este código dentro do script que contém o DOMContentLoaded
            document.addEventListener("DOMContentLoaded", function () {
                // Código existente...

                // Adicionar botões de salvar, exportar e importar
                const buttonContainer = document.querySelector(".botoesmapa");
                
                // Verify the container exists
                if (!buttonContainer) {
                    console.error("Botão container não encontrado");
                    return;
                }

                // Botão de salvar no localStorage
                const saveBtn = document.createElement("button");
                saveBtn.id = "saveLayersBtn";
                saveBtn.className = "btn btn-warning btn-sm";
                saveBtn.innerHTML = '<i class="fas fa-save"></i> Salvar Camadas';
                saveBtn.title = "Salvar camadas no navegador";
                buttonContainer.appendChild(saveBtn);

                // Botão de exportar
                const exportBtn = document.createElement("button");
                exportBtn.id = "exportLayersBtn";
                exportBtn.className = "btn btn-primary btn-sm ms-2";
                exportBtn.innerHTML = '<i class="fas fa-file-export"></i> Exportar';
                exportBtn.title = "Exportar camadas como arquivo";
                buttonContainer.appendChild(exportBtn);

                // Botão de importar
                const importBtn = document.createElement("button");
                importBtn.id = "importLayersBtn";
                importBtn.className = "btn btn-secondary btn-sm ms-2";
                importBtn.innerHTML = '<i class="fas fa-file-import"></i> Importar';
                importBtn.title = "Importar camadas de arquivo";
                buttonContainer.appendChild(importBtn);

                // Input para importar arquivo (oculto)
                const importInput = document.createElement("input");
                importInput.type = "file";
                importInput.id = "importLayersInput";
                importInput.accept = ".json";
                importInput.style.display = "none";
                document.body.appendChild(importInput);

                // Adicionar event listeners para os novos botões
                saveBtn.addEventListener("click", saveLayersToLocalStorage);

                exportBtn.addEventListener("click", exportLayers);

                importBtn.addEventListener("click", function () {
                    importInput.click();
                });

                importInput.addEventListener("change", function (e) {
                    if (this.files && this.files.length > 0) {
                        importLayers(this.files[0]).finally(() => {
                            // Limpar o input para permitir selecionar o mesmo arquivo novamente
                            this.value = "";
                        });
                    }
                });

                // Carregar camadas salvas ao iniciar a página
                window.addEventListener("load", function () {
                    // Tentar carregar as camadas do localStorage
                    setTimeout(() => {
                        loadLayersFromLocalStorage();
                    }, 500); // Pequeno atraso para garantir que o mapa foi inicializado
                });

                // Salvar automaticamente quando houver mudanças nas camadas
                const autoSaveEvents = ["layer-added", "layer-removed", "layer-edited", "layer-moved"];
                autoSaveEvents.forEach((eventName) => {
                    document.addEventListener(eventName, function () {
                        saveLayersToLocalStorage();
                    });
                });

                // Modificar as funções existentes para disparar eventos personalizados

                // Modificar a função addLayerToMap para disparar evento quando uma camada é adicionada
                const originalAddLayerToMap = addLayerToMap;
                window.addLayerToMap = function (...args) {
                    const result = originalAddLayerToMap.apply(this, args);
                    if (result) {
                        document.dispatchEvent(new CustomEvent("layer-added"));
                    }
                    return result;
                };

                // Modificar a função removeLayer para disparar evento quando uma camada é removida
                const originalRemoveLayer = removeLayer;
                window.removeLayer = function (...args) {
                    originalRemoveLayer.apply(this, args);
                    document.dispatchEvent(new CustomEvent("layer-removed"));
                };

                // Modificar a função moveLayer para disparar evento quando uma camada é movida
                const originalMoveLayer = moveLayer;
                window.moveLayer = function (...args) {
                    originalMoveLayer.apply(this, args);
                    document.dispatchEvent(new CustomEvent("layer-moved"));
                };

                // Modificar o evento de submit do formulário de edição para disparar evento quando uma camada é editada
                const editLayerForm = document.getElementById("editLayerForm");
                const originalSubmitHandler = editLayerForm.onsubmit;
                editLayerForm.addEventListener("submit", function (e) {
                    if (originalSubmitHandler) {
                        originalSubmitHandler.call(this, e);
                    }
                    document.dispatchEvent(new CustomEvent("layer-edited"));
                });
            });
        </script>
    </body>
</html>
